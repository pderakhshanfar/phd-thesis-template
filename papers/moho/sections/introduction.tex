% In recent years, several evolutionary-based techniques have been proposed for automating  white-box test generation~\cite{Fraser2011, braione2017tardis, braione2018sushi, prasetya2013t3, Arcuri2019, Soltani2018a, Rossler2013} to ease software testing and debugging. These approaches generate tests satisfying various testing criteria (such as structural coverage, weak mutation, \etc) by  

% When a software application crashes, a report (or issue), including information gathered during the crash, is assigned to developers for debugging \cite{white2015}. One common practice to identify the root cause of a crash is to provide a test case that reproduces it \cite{Zeller2009}. This test case can later be adapted and integrated into the test suite to prevent future regressions. However, this test case is not always available in the crash reports. Also, depending on the amount of information available in the report, writing this \emph{crash reproducing test case} can be time-consuming and labor-intensive \cite{Soltani2018a}.

% Consequently, various approaches have been proposed in the literature to automate \emph{crash reproduction} \cite{Chen2015, jin2012bugredux, Xuan2015, Nayrolles2017, nayrolles2015jcharming, BPT17concrash, Rossler2013, Soltani2018a}.
% These approaches use the information about a crash (\eg stack traces from crash reports) to generate a crash reproducing test case by utilizing different techniques such as symbolic execution, model checking, \etc
% Among these approaches, two evolutionary-based techniques have been introduced: \textsc{ReCore}~\cite{Rossler2013} and \evocrash \cite{Soltani2018a}. These two approaches generate test cases able, when executed, to reproduce the target crash using single-objective evolutionary algorithms. %They reformulate the crash reproduction problem as a single search objective and apply a single-objective search algorithm to generate solutions (\ie tests).
% The empirical evaluation of \evocrash \cite{Soltani2018a} shows that it outperforms other, evolutionary-based and non-evolutionary-based approaches in terms of \emph{crash reproduction ratio} (percentage of crashes that could be reproduced) and \emph{efficiency} (time taken to reproduce a given crash successfully). This evaluation also confirms that \evocrash significantly helps developers during debugging.

\evocrash relies on a single-objective evolutionary algorithm (\textit{\SGGA} hereafter) that evolves test cases according to an objective (\CrashFunction hereafter) measuring how far a generated test is from reproducing the crash. \CrashFunction combines three heuristics: \textit{line coverage} (how far is the test from executing the line causing the crash?), \textit{exception coverage} (does the test throw the same exception as in the crash?), and \textit{stack trace similarity} (how similar is the exception stack trace from the one reported in the crash?). %By using these heuristics, \CrashFunction measures how far a generated test is from triggering the target crash.
%
Although \SGGA performs well compared to the other crash reproduction approaches, a more extensive empirical study in Chapter \ref{sec:jcrashpack:introduction} evidenced that it is not successful in reproducing complex crashes (\ie large stack traces). Hence, further studies to enhance the guidance of the search process are required.

Just like any other evolutionary-based algorithm, \SGGA requires to maintain a balance between \textit{exploration} and \textit{exploitation} \cite{vcrepinvsek2013}. The former refers to the generation of completely new solutions (\ie test cases executing new paths in the code); the latter refers to the generation of solutions in the neighborhood of the existing ones (\ie test cases with similar execution paths). \SGGA ensures exploitation through Guided Mutation, which guarantees that each solution contains the method call causing the crash (and reported in the stack trace) \cite{Soltani2018a}. However, the low exploration of \SGGA may lead to a lack of diversity, trapping the search in local optima \cite{vcrepinvsek2013}.

To tackle this problem, our prior study \cite{Soltani2018b} investigated the usage of \textit{De\-com\-po\-si\-tion-based Multi-Objectivization} (\decomposition) to decompose the \CrashFunction in three distinct (sub-)objectives. A target crash is reproduced when the search process fullfils all three sub-objectives at the same time. The empirical evaluation shows that \decomposition slightly improves the efficiency for some crashes. 
However, since the sub-objectives are not conflicting, while conflicting objectives maintain more diversity in the population and guide the search process away from local optima \cite{jensen2004helper}, their combined usage can be detrimental for crash reproduction \cite{Soltani2018b}.
Our other previous study \cite{Derakhshanfar2020a} also conjectured that increasing diversity via additional objective is a feasible yet unexplored research direction to follow. However, no systematic empirical study has been conducted to evaluate that hypothesis further.

In this study, we investigate a new strategy to Multi-Objectivize crash reproduction based on Helper-Objectives (\moho) rather than decomposition. More specifically, we add two additional helper-objectives to \CrashFunction (first objective):  \textit{method sequence diversity} (second objective) and \textit{test case length minimization} (third objective). 
The second objective aims to increase the diversity in the method sequences; more diverse sequences are more likely to cover diverse paths and, consequently, improve exploration. The third objective aims to address the \textit{bloating effect} (\ie the generated test cases can become longer and longer after each generation until the all of the system memory is used), as diversity can lead to an unnecessary and counter-productive increase of the test case length~\cite{albunian2017diversity, Panichella2018}.
Since these three objectives are \textit{conflicting}, we expect an improvement in the solutions' diversity and, hence, improving the effectiveness (crash reproduction ratio) and efficiency. 


To assess the performance of \moho on crash reproduction, we use five multi-objective evolutionary algorithms (MOEAs): NSGA-II~\cite{deb2002fast}, SPEA2 \cite{zitzler2001spea2}, MOEA/D \cite{zhang2007moea}, PESA-II \cite{Corne2001}, and FEMO \cite{laumanns2002}. 
We apply them to 124 non-trivial crashes from \crashpack (Chapter \ref{sec:jcrashpack:introduction}). 
Those crashes can only be reproduced by a test case that brings the software under test to a specific state and invokes the target method with one or more specific input parameters. 
We performed an internal assessment among \moho algorithms to find the best multi-objective evolutionary algorithm for this optimization problem.
According to the results observed in this assessment, \textit{SPEA2} outperforms other MOEAs in crash reproduction using \moho helper-objectives.

Furthermore, we compared the best-performing \moho (\moho + \textit{SPEA2}) against two state-of-the-art  approaches (\SGGA \cite{Soltani2018a} and \decomposition \cite{Soltani2018b}) from the perspectives of \textit{crash reproduction ratio} and \textit{efficiency}. Our results show that \moho outperforms the state-of-the-art in terms of crash reproduction ratio and efficiency.
This algorithm improves the crash reproduction ratio by up to 100\% and 93.3\% (10\% and 8\%, on average) compared to \SGGA and \decomposition, respectively.
% After one minute of the crash reproduction, \moho reproduces eight crashes (6.5\% of crashes) and seven crashes (5.5\% of crashes) more than \SGGA and \decomposition, respectively.
 Also, after five minutes of search, \moho reproduces five and six crashes (4\% and 5\% more crashes) that cannot be reproduced by \SGGA and \decomposition, respectively.
In addition, \moho reproduces crashes significantly faster than \SGGA and \decomposition in 34.6\% and 37.9\% of the crashes, respectively. 

A replication package, enabling the full-replication of our evaluation and data analysis of our results is available on Zenodo \cite{zenodoRP}. 