

% Search-based test case generation enables the automated generation of test cases according to predefined criteria. Among the different approaches, white-box search-based test case generation \cite{Fraser2011, Fraser2014b, Panichella2018} relies on evolutionary algorithms to generate test cases from source code and maximize structural coverage~\cite{Fraser2014b, Panichella2018} or mutation score~\cite{Fraser2015a}. 
% Previous research has shown that automatically generated tests are effective for coverage and fault finding~\cite{Campos2018, Kracht2014, Panichella2018a}, can also find real faults~\cite{almasi2017industrial}, and are useful for debugging~\cite{Ceccato2015}.

Despite several advances, search-based unit test generation still faces many challenges. Among those are (i) the crafting of complex objects and values used during test generation~\cite{almasi2017industrial}, and 
(ii) the indirect coverage of encapsulated elements (\eg private methods and class attributes) through the invocation of specific paths in public methods~\cite{Salahirad2019}. 
Various approaches address those challenges by relying on \emph{dynamic symbolic execution} to generate complex objects and values using constraint solvers~\cite{Inkumsah2008, Lakhotia2010, Galeotti2013, Gouraud2001}; 
\emph{seeding} to identify objects and values from the application source and test code that are later reused during the search~\cite{Rojas2016}; 
or class usages, learned from static analysis of the source code~\cite{Fraser2011a} and dynamic execution of the existing tests (like behavioral model seeding introduced in Chapter \ref{sec:model_seeding}), and used to generate realistic objects.

However, if complex objects and values can indeed lead to an improvement in the coverage, it does not always succeed in covering all the elements of a class under test. For instance, if the indirect coverage of a private method requires specific executions paths in a public method, the current fitness functions will not be able to provide sufficient guidance to the search process~\cite{Salahirad2019}. 

In this chapter, we hypothesize that common and uncommon execution paths, observed during the actual operation of the system, can lead to better guidance of the search process, and hence, better coverage. Complementing previous work on seeding~\cite{Rojas2016}, which is aimed at triggering different execution paths in the methods under test, we consider the \emph{commonality} of those execution paths. For that, we approximate commonality using weights for the different code blocks, and define a secondary objective called the \emph{commonality score}, denoting how close an execution path is from common or uncommon executions of the software.

We implemented the commonality score in \evosuite~\cite{Fraser2011} and evaluated it on 150 classes from \jabref, an open-source bibliography reference manager, for common and uncommon behaviors. We compare the commonality score (\textbf{RQ.1}), the structural coverage (\textbf{RQ.2}), and the fault-finding capabilities (\textbf{RQ.3}) of the thus generated tests to tests generated by the standard \evosuite implementation. Our results are mixed but show that this secondary objective significantly improves the number of covered common paths in 32.6\% of the classes. 
Although the average structural coverage remains stable, the commonality score significantly improves the line (resp. branch) coverage in three (resp. four) classes, but also negatively impacts the coverage for eight (resp. nine) classes. Finally, the commonality score impacts the number of killed mutants for 22 classes (11 positively and 11 negatively).
%
Our implementation is openly available at \url{https://github.com/STAMP-project/evosuite-ramp}, and the replication package of our evaluation and data analysis have been uploaded to Zenodo \cite{evers_bjorn_2020_3897513, evers_bjorn_2020_3894711}. 




