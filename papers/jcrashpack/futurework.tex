
From the evaluation and the challenges derived from our manual analysis, we devise the following future research directions. 
While the same challenge can be addressed in different ways, some requiring technical improvements of \evocrash and other raising new research directions, we focus the discussion of this section on the latter. 

\subsection{Context Matters}

While search-based crash-reproduction with \evocrash~\cite{soltani2017,Soltani2018a} outperformed other approaches based on \begin{inparaenum}[(i)]
\item backward symbolic execution \cite{Chen2015},
\item test case mutation \cite{Xuan2015},
and \item model-checking \cite{Nayrolles2017},
\end{inparaenum}
our evaluation shows that the extent to which crashes are reproduced varies.
These results indicate the need for taking various types of contexts and properties of software applications into account when devising an approach to a problem.
Thus, we show that indeed, rather than seeking a universal approach to search-based crash reproduction, it is important to find out and address challenges specific to various types of application domains (e.g., RESTful microservices vs. enterprise wiki applications) \cite{Arcuri2017b}.

Furthermore, search-based crash replication boils down to seeking the execution path that will reproduce a given stack trace.
As with other search-based testing approaches, it faces challenges about \emph{input data generation} during the search when the input space is large.
Previous research on \textit{mocking} and \textit{seeding} \cite{arcuri2017private,Rojas2016} address this problem by using functional mocking and extracting objects and constants from the bytecode.

We believe that \emph{taking context into account} should go one step further for crash replication.
With the development of DevOps \cite{Roche2013} and continuous integration and delivery pipelines, there is an increasing amount of available data on the execution of the software.
Those data can be used to guide the search more accurately.
For instance, by seeding the search using values observed in the execution logs and setting up values for \emph{environmental dependencies} (databases, external services, etc.).


\subsection{Stack Trace Preprocessing And Target Frame Selection}

Various factors may influence the selection of a target frame in a stack trace.
As observed in our evaluation, when not performed cautiously, this selection leads to unsuccessful executions of \evocrash.
For instance, frames targeting code in a \emph{private inner class}, or \emph{irrelevant} source code location (like, as we observed, class header or annotation) should be discarded before performing the selection.

Frames targeting code in \emph{abstract classes} or \emph{interfaces} (only if the target method is defined in the interface, which is possible from Java 8) may be of some use to find the cause of the crash:  for instance, to identify an incorrect subclass implementation \cite{Liskov2000}.
However, as abstract classes and interfaces cannot be directly instantiated, the stack trace generated by \evocrash can never be exactly the same as the given stack trace.
And, as for \emph{input arguments} and \emph{generic type parameters}, \evocrash has no indication on which subclass to pick, making the search difficult.
In this case, considering higher level frames (i.e., frames that are lower in the stack trace) may help to pick the right subclass.

Those reasons motivate the need to develop \emph{stack trace analysis techniques} in order to help the \emph{selection} of a target frame.
This analysis will discard irrelevant and unknown source location frames and provide a visualization to the developer to have a clear view on what are his or her options, for instance by marking stack traces that point to interfaces and abstract classes and recommend him to pick higher level frames.

For a given stack trace, this analysis will also identify frames pointing to a \emph{try/catch} block.
Those stack traces are commonly reported by users to issue tracking systems but cannot (for now) be completely reproduced by \evocrash.
Further investigation on current error handling practices in Java code \cite{Cabral2007,Coelho2017} and how they are reported by users \cite{Maiga2015} will help us to devise efficient approaches to replicate such stack traces.

\subsection{Guided Search}

Besides usage of contextual information to enhance the generation of test cases during the search process, we also consider to enhance the guidance itself.
Search based testing algorithms have several parameters (365 in \evocrash), like population size, search budget, probability of applying crossover and mutation, etc. 
As demonstrated by Arcuri and Fraser \cite{Arcuri2011a}, default parameters values work well on average, but may be fare from optimal for specific frames and stack traces. 
A better characterization of the stack traces in \crashpack, trying different \emph{parameters}, as well as improving the \emph{fitness function} itself are part of our future work.
For instance the fitness function could take other elements into account (e.g., compute a similarity for exception messages).
We will also consider multi-objectives search, where, for a given target frame, reproducing each lower  frame becomes an objective of the search.
We plan to reuse our evaluation infrastructure to compare those different approaches and investigate their different fitness landscapes to gain deeper understanding of the search process for crash reproduction. And eventually devise guidelines on \evocrash settings to maximize crash reproduction for a given stack trace and its characteristics.

\subsection{Improving Testability}

Finally, as we observed, code complexity was among the major challenges in crash reproduction with \evocrash.
To improve testability, several testability transformation techniques \cite{McMinn2011, LiBytecodeTT, MarkFlag,MarkFlagRemoval, MarkLoopFlag} have been proposed in the literature so far.
Future research may investigate testability transformation techniques and their impact on search-based crash reproduction.
