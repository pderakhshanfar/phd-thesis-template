\chapter{Introduction}
\label{introduction}

\begin{abstract}
Sample Abstract. 
\end{abstract}

\blfootnote{This chapter is partly based on \faFileTextO~\emph{}~\cite{}.
 }


\newpage
\dropcap{S}oftware testing is an indispensable part of software engineering, and it has been widely studied from different aspects by researchers in this field. As explained by Bertolino \cite{bertolino2007software}, one of the biggest dreams in software testing research is building a 100\% automatic testing framework. One of the research paths towards reaching this dream is the automated test generation.

A survey by McMinn \cite{McMinn2004} shows that search-based software test generation techniques are applicable to a vast range of automated software testing problems (including automated test generation). The application of metaheuristic search-based approaches for automating the process of software test generation has been an interesting research path in recent years. The introduced approaches model the software testing goals, which should be achieved by manually-written test cases, into optimization problems and solve them using search algorithms. 

The introduced search-based test generation approaches aim to produce tests for different objectives. For instance, many approaches are proposed for unit testing \cite{Fraser2011, braione2017tardis, braione2018sushi, prasetya2013t3} and system-level testing \cite{Arcuri2019, Holler2012, Padhye2019, beyene2012, coppit2005, godefroid2008}. Moreover, these approaches can be categorized into white-box \cite{Fraser2011, braione2017tardis, braione2018sushi, prasetya2013t3, Arcuri2019} and black-box \cite{Holler2012, Padhye2019, beyene2012, coppit2005, godefroid2008} testing techniques. 

The evaluations that were performed indicate the usefulness of the generated tests. The generated tests can not only achieve high structural and mutation coverage~\cite{Panichella2018a, Fraser2014b}, but are also helpful for catching faults~\cite{Shamshiri2016} and debugging~\cite{Ceccato2015}. They have also been successfully deployed in industry~\cite{Alshahwan2018, almasi2017industrial}.

Most of these approaches aim at a general coverage criteria (\eg line and branch coverage). However,  generated tests with high structural coverage are not always successful at detecting faults. Gay \etal \cite{gay2015risks} have shown that these types of coverage criteria are poor indicators for failure detection and mutation score in some cases. As an example, a test case can cover a statement without passing failure revealing data. In this case, we have the coverage, but the fault will remain undetected.
Moreover, Shamshiri \etal \cite{Shamshiri2016} reported that the tests generated by \evosuite, which is one of the better automatic unit test generation tools, are only successful in exposing about 50\% of industrial faults despite the high structural coverage scores. 

Furthermore, search-based test generation for specific problems has a lot of open challenges. Among them, fitness functions defined for search-based test generation suffer from a lack of guidance and underuse contextual information.  
In particular, Salahirad \etal \cite{Salahirad2019} indicated that the strongest fitness function (branch coverage) has about 25\% likelihood of fault detection.
As an outcome, they suggest using classical branch and line coverage as primary objectives and using other objectives that aid to trigger the faults as secondary objectives.

In this thesis, we go beyond classical search objectives based on structural coverage. In other words, we concentrate on defining helpful search objectives, and exercising specific behavior, for triggering specific kinds of faults. First, we focus on test generation for crash reproduction. Crash reproduction approaches \cite{Soltani2018a, BPT17concrash, Chen2015, Nayrolles2017, Rossler2013, Xuan2015} accept a crash as input and generate a test that reproduces this given crash. Second, we concentrate on generating tests for exercising integration points between two classes. We consider the execution of different scenarios in the interaction between two coupled classes as test objectives for the test generation process.

\section{Background \& Context}

This section presents an overview of search-based software test generation and automated crash reproduction and how they are connected to this thesis.

\subsection{Search-based Sofrware Test Generation}

\subsection{Automated Crash Reproduction}

\section{Research Goals \& Questions}
Research questions:


\textbf{RQ$_1$: } \textit{What are the challenges in search-based crash reproduction?}

\textbf{RQ$_2$: } \textit{Based on the identified challenges, how can we leverage the existing knowledge, carved from information sources, to steer the crash reproduction search process?}

\textbf{RQ$_3$: } \textit{How can we utilize the knowledge gained from static and dynamic analysis to design search-based test generation approaches for other criteria?}


\section{Research Outline}

Chapters:

\textbf{Chapter 2: } JCrashPack paper (adressing $RQ_1$)


\textbf{Chapter 6: } Model seeding (adressing $RQ_2$)

\textbf{Chapter ?: } Multi-objectivization paper (adressing $RQ_2$)

\textbf{Chapter 4: } MOHO paper (adressing $RQ_2$)

\textbf{Chapter 5: } Basic Block Coverage paper (adressing $RQ_2$)

\textbf{Chapter 3: } CLING paper (adressing $RQ_3$)

\textbf{Chapter ?: } Common behavior (adressing $RQ_3$)

\textbf{Chapter 7: } Conclusion


\section{Research Methodology}

Design science \cite{Hevner2004}

\section{Open Science}

% In this thesis \cite{Derakhshanfar2020}, you can reference pictures~\Cref{fig:devmodel} using Cleverref and circles \circled{5}.

% \begin{figure}[htb]
% 	\centering
% 	\includegraphics[width=0.65\columnwidth]{development_model_without_papers}
% 	\caption{The stages of the FDD model and their relationship to other
%           Software Engineering concepts.}
% 	\label{fig:devmodel}
% \end{figure}

% We also have lists:

% \begin{enumerate}
%   \item Static Analysis~\circled{3} examines program artifacts or
%     their source code without executing them~\cite{wichmann1995industrial}, while
%  \item Dynamic Analysis~\circled{4} relies on information gathered from their
%    execution~\cite{cornelissen2009systematic}.
% \end{enumerate}

% Or boxes:

% \begin{framed}
% This thesis is concerned with the empirical assessment of the state of the art of how developers
% drive software development with the help of feedback loops.
% \end{framed}

% Or code:
% \begin{lstlisting}[caption={\textsc{TrinityCore}},label={lst:e1}]
%  x += other.x;
%  y += other.y;
%  z += other.y;
% \end{lstlisting}




% Long: \acrlong{fdd}

% Short: \acrshort{fdd}

% Full: \acrfull{fdd}
