\chapter{Introduction}
\label{introduction}

\begin{abstract}
Sample Abstract. 
\end{abstract}

\blfootnote{This chapter is partly based on \faFileTextO~\emph{P. Derakhshanfar. Well-informed Test Case Generation and Crash Reproduction, ICST'20 (Doctoral Symposium)}~\cite{derakhshanfar2020well}.
 }


\newpage
\dropcap{S}oftware testing is an indispensable part of software engineering, widely studied from various aspects by researchers in this field. As mentioned by Bertolino~\cite{bertolino2007software}, one of the biggest dreams in software testing research is 100\% automatic testing, and one of the research paths towards reaching this dream is the automated test generation.

A survey by McMinn \cite{McMinn2004} shows that search-based software test generation techniques are applicable to a vast range of automated software testing problems, including automated test generation. The application of metaheuristic search-based approaches for automating the process of software test generation has been an interesting research path in recent years. The introduced approaches model the software testing goals, which should be achieved by manually-written test cases, into optimization problems and solve them using search algorithms. 

The introduced search-based test generation approaches aim to produce tests for different levels of testing. For instance, many approaches are proposed for unit testing \cite{Fraser2011, braione2017tardis, braione2018sushi, prasetya2013t3} and system-level testing \cite{Arcuri2019, Holler2012, Padhye2019, beyene2012, coppit2005, godefroid2008}. Moreover, these approaches can be categorized into white-box \cite{Fraser2011, braione2017tardis, braione2018sushi, prasetya2013t3, Arcuri2019} and black-box \cite{Holler2012, Padhye2019, beyene2012, coppit2005, godefroid2008} testing techniques. 

The evaluations that were performed indicate the usefulness of the generated tests. The generated tests can not only achieve high structural and mutation coverage~\cite{Panichella2018a, Fraser2014b}, but are also helpful for catching faults~\cite{Shamshiri2016} and debugging~\cite{Ceccato2015}. They have also been successfully deployed in industry~\cite{Alshahwan2018, almasi2017industrial}.

Most of these approaches aim at a general coverage criteria (\eg line and branch coverage). However,  generated tests with high structural coverage are not always successful at detecting faults. Gay \etal \cite{gay2015risks} have shown that these types of coverage criteria are poor indicators for failure detection and mutation score in some cases. As an example, a test case can cover a statement without passing failure revealing data. In this case, we have the coverage, but the fault will remain undetected.
Moreover, Shamshiri \etal \cite{Shamshiri2016} reported that the tests generated by \evosuite, which is one of the better automatic unit test generation tools, are only successful in exposing about 50\% of industrial faults despite the high structural coverage scores. 

Furthermore, search-based test generation for specific problems has a lot of open challenges. Among them, fitness functions defined for search-based test generation suffer from a lack of guidance and underuse contextual information.  
In particular, Salahirad \etal \cite{Salahirad2019} indicated that the strongest fitness function (branch coverage) has about 25\% likelihood of fault detection.
As an outcome, they suggest using classical branch and line coverage as primary objectives and using other objectives that aid to trigger the faults as secondary objectives.

In this thesis, we go beyond classical search objectives based on structural coverage. In particular, we investigate how information collected from different sources (\ie source code, manually-written tests, \etc) can reinforce search objectives. In doing so, we hypothesize that we can exercise specific behaviors, and thus trigger specific kinds of faults.


First, we focus on one of the instances of test generation for specific software behaviors: \textbf{search-based crash reproduction}. These approaches~\cite{Soltani2018a, BPT17concrash, Chen2015, Nayrolles2017, Rossler2013, Xuan2015} accept a crash as input and generate a test that reproduces this given crash. Our studies on crash reproduction focus on leveraging the collected contextual information to improve the effectiveness (\ie the number of reproduced crashes and how often they can be reproduced) and efficiency (\ie the time required to reproduce a crash) of the search process, trying to reproduce the given crash.

Second, we concentrate on generating tests for \textbf{exercising integration points between two classes}. We consider the execution of different scenarios in the interaction between two coupled classes as test objectives for the test generation process. We introduce a new test criterion for class integration testing, which is suitable for defining search objectives. Then, we design a search-based test generation algorithm according to this newly defined criterion. We investigate if this algorithm can reveal integration level faults which are not detectable with search-based unit testing.

Finally, we investigate a novel search objective for search-based unit testing that covers the \textbf{common and uncommon execution patterns}. To detect the common/uncommon patterns, we monitor the execution patterns during the operation of the software.

\section{Background \& Context}
\input{introduction/background}

\section{Challenges In Search-based Crash Reproduction And Test Generation}
Since the search-based crash reproduction approaches are evaluated by a limited number of crashes, the limits and challenges of these techniques remained unrecognized.
In this thesis, we want to identify search-based crash reproduction challenges. Hence, we empirically evaluate search-based crash reproduction by a new Java crash benchmark called \jcrashpack and identify the challenges by performing an extensive manual analysis. Some of the identified challenges are dedicated only to the crash reproduction problem, but some other challenges are general search-based test generation issues.

After identifying the challenges, we want to address them by introducing novel solutions to improve the effectiveness and efficiency of the crash reproduction search process. For this goal, we investigate the application of contextual information collected from different sources such as source code, manually-written test cases. While some identified challenges in search-based crash reproduction are due to the existing general search-based test generation limitations, we can go beyond crash reproduction and introduce new search-based techniques to cover other specific software behaviors.

\section{Research Goals \& Questions}
To present indications towards this thesis, we seek to answer the following research questions:

Since our initial goal is improving the effectiveness and efficiency of the search-based crash reproduction, first, we need to understand its challenges. Hence, the first research question tries to address this goal.
\begin{framed}
\quad\textbf{RQ$_1$: } \textit{What are the challenges in search-based crash reproduction?}
\end{framed}

After identifying the challenges, we study novel ways to tackle them by enhancing the search process from different aspects. This enhancement is done by utilizing the contextual information collected from source code and existing tests. The second research question investigates the new techniques addressing the detected challenges using the observed contextual information.


\begin{framed}
    
    \textbf{RQ$_2$: } \textit{Based on the identified challenges, how can we leverage the existing knowledge, carved from information sources, to steer the crash reproduction search process?}

\end{framed}

Since some of the detected challenges in search-based crash reproduction are observable in other search-based test generation techniques, the observed contextual information can guide the search process to generate tests for other criteria, as well. Hence, the last question concentrates on novel search-based techniques for testing in two levels of unit testing and class integration testing.

\begin{framed}
    \textbf{RQ$_3$: } \textit{How can we leverage the existing knowledge, carved from information sources, to design search-based test generation approaches for unit and class integration testing?}
\end{framed}

This thesis answers $RQ_3$ by (i) introducing a whole new search-algorithm for class integration testing using the collected information about the method calls from one class (\textit{caller class}) to the other one (\textit{callee class}), and (ii) introducing a new search objective for search-based unit testing considering the common and uncommon execution paths in the class under test.

After answering these research questions, we will be able to understand the challenges in search-based software test generation better. Besides, We can confirm that (i) automated test generation for specific software behaviors can cover, and reveal, faults that are not detectable by other search-based test generation techniques, using only the classical structural coverage search objectives; and (ii) using other contextual information collected from various sources (such as source code, existing test cases, and execution logs) guides the search process to achieve higher fault detection.





\section{Research Outline}

This section briefly presents the various chapters in this thesis.
Table \ref{tab:chaptersvsRQs} outlines the connections between each defined research question and chapters in this thesis.


\begin{table}[!t]
\caption{Connection of chapters with research questions}
\label{tab:chaptersvsRQs}
\begin{tabular}{|p{0.8\textwidth}||c|}
\textbf{Research Question} & \textbf{Chapters}\\
\hline
\hline
$RQ_1$: What are the challenges in search-based crash reproduction? & 2\\
$RQ_2$: Based on the identified challenges, how can we leverage the existing knowledge, carved from information sources, to steer the crash reproduction search process? & 3 to 5\\
$RQ_3$: How can we leverage the existing knowledge, carved from information sources, to design search-based test generation approaches for unit and class integration testing? & 6 \& 7\\
\hline
\end{tabular}
\end{table}


\paragraph{Chapter 2:}%JCrashPack paper (adressing $RQ_1$)
Crash reproduction approaches help developers during debugging by generating a test case that reproduces a given crash. 
Several solutions have been proposed to automate this task.
However, the proposed solutions have been evaluated on a limited number of projects, making comparison difficult.
In this chapter, we enhance this line of research by proposing \crashpack, an extensible benchmark for Java crash reproduction, together with \exrunner, a tool to simply and systematically run evaluations.
\crashpack contains 200 stack traces from various Java projects, including industrial open source ones, on which we run an extensive evaluation of \evocrash, the state-of-the-art approach for search-based crash reproduction.
Our results include a detailed manual analysis of \evocrash outputs, from which we derive 14 current challenges for crash reproduction. 
Finally, based on those challenges, we discuss future research directions for search-based crash reproduction for Java.

\paragraph{Chapter 3:}%Model seeding (adressing $RQ_2$)
According to the results of Chapter 2, one of the fundamental challenges of search-based crash reproduction is creating objects needed to trigger the crash. One way to overcome this limitation is seeding: using information about the application during the search process. With seeding, the existing usages of classes can be used in the search process to produce realistic sequences of method calls which create the required objects. In this chapter, we introduce behavioral model seeding: a new seeding method which learns class usages from both the system under test and existing test cases.  Learned usages are then synthesized in a behavioral model (state machine). Then, this model serves to guide the evolutionary process. To assess behavioral model-seeding, we evaluate it against test-seeding (the state-of-the-art technique for seeding realistic objects) and no-seeding (without seeding any class usage). 
Our results indicate that behavioral model-seeding outperforms both test seeding and no-seeding by a minimum of 6\% without any notable negative impact on efficiency.

%\textbf{Chapter ?: } Multi-objectivization paper (adressing $RQ_2$)

\paragraph{Chapter 4:}% MOHO paper (adressing $RQ_2$)
The state-of-the-art search-based crash reproduction approaches use a single fitness function called \CrashFunction to guide the search process toward reproducing a target crash. Despite the reported achievements, these approaches do not always successfully reproduce some crashes due to a lack of test diversity (premature convergence). In this study, we introduce a new approach, called \moho, that addresses this issue via multi-objectivization. In particular, we introduce two new Helper-Objectives for crash reproduction, namely \textit{test length} (to minimize) and \textit{method sequence diversity} (to maximize), in addition to \CrashFunction.
We assessed \moho using five multi-objective evolutionary algorithms (NSGA-II, SPEA2, PESA-II, MOEA/D, FEMO) on crashes selected from \crashpack. Our results indicate that SPEA2 is the best-performing multi-objective algorithm for \moho.
We evaluated this best-performing algorithm for \moho against the state-of-the-art: single-objective approach (\SGGA) and decomposition-based multi-objectivization approach (\decomposition). Our results show that \moho reproduces five crashes that cannot be reproduced by the current state-of-the-art. Besides, \moho improves the effectiveness (+10\% and +8\% in reproduction ratio) and the efficiency in 34.6\% and 36\% of crashes (i.e., significantly lower running time) compared to  \SGGA and \decomposition, respectively. For some crashes, the improvements are very large, being up to +93.3\% for reproduction ratio and -92\% for the required running time. 

\paragraph{Chapter 5:}%Basic Block Coverage paper (adressing $RQ_2$)
Search-based crash reproduction approaches rely on the \emph{approach level} and \emph{branch distance} heuristics to guide the search process and generate test cases covering the lines, which are appeared in the given stack trace.
Despite the positive results achieved by these two heuristics, they only use the information related to the coverage of explicit branches (\eg indicated by conditional and loop statements), but ignore potential implicit branchings within basic blocks of code. 
If such implicit branching happens at runtime (\eg if an exception is thrown in a branchless-method), the existing fitness functions cannot guide the search process. 
To address this issue, we introduce a new secondary objective, called Basic Block Coverage (\bbc), which takes into account the coverage level of relevant basic blocks in the control flow graph. We evaluated the impact of \bbc on \emph{search-based crash reproduction} because the implicit branches commonly occur when trying to reproduce a crash, and the search process needs to cover only a few basic blocks (\ie blocks that are executed before crash happening). We combined \bbc with existing fitness functions (namely \integ and \WS) and ran our evaluation on \crashpack crashes.
Our results show that \bbc, in combination with \integ and \WS, reproduces 6 and 1 new crashes, respectively.
\bbc significantly decreases the time required to reproduce 26.6\% and 13.7\% of the crashes using \integ and \WS, respectively. For these crashes, \bbc reduces the consumed time by 44.3\% (for \integ) and 40.6\% (for \WS) on average.

\paragraph{Chapter 6:}%CLING paper (adressing $RQ_3$)
Search-based approaches have been used in the literature to automate the process of creating unit test cases. However, related work has shown that generated unit-tests with high code coverage could be ineffective, i.e., they may not detect all faults or kill all injected mutants. 
In this chapter, we propose \cling, an integration-level test case generation approach that exploits how a pair of classes, the caller and the callee, interact with each other through method calls. In particular, \cling generates integration-level test cases that maximize the Coupled Branches Criterion (CBC). CBC is a novel integration-level coverage criterion, measuring the degree to which a test suite exercises the interactions between a caller and its callee classes. 
We implemented \cling and evaluated the approach on 140 pairs of classes from five different open-source Java projects. Our results show that (1) \cling generates test suites with high CBC coverage; (2) such generated suites can kill 
on average 7.7\% (with a maximum of 50\%) of mutants that are not detected by tests generated at the unit level; (3) \cling can detect integration faults (32 for our subject systems) that remain undetected when using automatically generated unit-level test suites. 

\paragraph{Chapter 7:}%Common behavior (adressing $RQ_3$)
Various search-based test generation techniques have been proposed to automate the generation of unit tests fulfilling different criteria (\eg line coverage, branch coverage, mutation score, \etc). Despite several advances made over the years, search-based unit test generation still suffers from a lack of guidance due to the limited amount of information available in the source code that, for instance, hampers the generation of complex objects. Previous studies introduced many strategies to address this issue, \eg dynamic symbolic execution or seeding, but do not take the internal execution of the methods into account.  
This chapter introduces a novel secondary objective called \emph{commonality score}, measuring how close the execution path of a test case is from reproducing a \emph{common} or \emph{uncommon} execution pattern observed during the operation of the software.
To assess the commonality score, we implemented it in \evosuite and evaluated its application on 150 classes from \jabref, an open-source software for managing bibliography references. 
Our results are mixed. Our approach leads to test cases that indeed follow \emph{common} or \emph{uncommon} execution patterns. However, if the commonality score can have a positive impact on the structural coverage and mutation score of the generated test suites, it can also be detrimental in some cases. 

\paragraph{Chapter 8:} 
Finally, we summarize our findings and conclusions in this thesis. This chapter also elaborates on the potential future works that can, first, improve the search-based crash reproduction, and second, investigate novel search-based algorithms for covering other software specific behaviors that can be interesting for developers.


\section{Research Methodology}

\input{introduction/methodology}


\section{Origins of the chapters}
All chapters of this thesis (except Chapter 7, which is currently under review) have been published in peer-reviewed journals and conferences. 
Hence, some chapters contain a dedicated background, related work, and conclusion section. 
This section lists the origin of each chapter.

\begin{itemize}
    \item \textit{Chapter 2} was published in the paper "A benchmark-based evaluation of search-based crash reproduction" in Empirical Software Engineering Journal (EMSE) 2020.
    \item \textit{Chapter 3} was published in the paper "Search‐based crash reproduction using behavioural model seeding" in Journal of Software: Testing, Validation, and Reliability (STVR) 2020.
    \item \textit{Chapter 4} was published in the paper " Good Things Come In Threes: Improving Search-based Crash Reproduction With Helper Objectives" at International Conference on Automated Software Engineering (ASE) 2020.
    \item \textit{Chapter 5} was published in the paper "It is not Only About Control Dependent Nodes: Basic Block Coverage for Search-Based Crash Reproduction" at Symposium on Search-Based Software Engineering (SSBSE) 2020.
    \item \textit{Chapter 6} was published is a paper called "Generating Class-Level Integration Tests Using Call Site Information", which is currently under revision in Transactions on Software Engineering journal (TSE).
    \item \textit{Chapter 7} was published in the paper "Commonality-Driven Unit Test Generation" at Symposium on Search-Based Software Engineering (SSBSE) 2020.
  \end{itemize}

\section{Open Science}

Open science is the “movement to make scientific research, data and dissemination accessible to all levels of an inquiring society” \cite{Open_science}. All of the implementations used in our studies are available via GitHub. Also, replication packages of all of our studies, presented in this thesis, are available openly in Zenodo. These replication packages contain the list of subjects used in each study, a Docker-based infrastructure to rerun all of the experiments, and all test cases generated by each of the search-based approaches.

Table \ref{tab:replicationpackages} shows the replication package of each chapter in this thesis.


\begin{table}[!t]
    \begin{center}
        
    
    \caption{Connection of chapters with replication packages}
    \label{tab:replicationpackages}
    \begin{tabular}{|c||c|}
    \textbf{Chapter} & \textbf{Replication package}\\
    \hline
    \hline
    2 & \cite{zenodoJCrashPack} \\
    3 & \cite{pouria_derakhshanfar_2019_3673916} \\
    4 & \cite{zenodoRP} \\
    5 & \cite{derakhshanfar_pouria_2020_3953519} \\
    6 & \url{https://github.com/STAMP-project/Cling-application} \\
    7 & \cite{evers_bjorn_2020_3894711} \\
    \hline
    \end{tabular}
\end{center}
    \end{table}
% In this thesis \cite{Derakhshanfar2020}, you can reference pictures~\Cref{fig:devmodel} using Cleverref and circles \circled{5}.

% \begin{figure}[htb]
% 	\centering
% 	\includegraphics[width=0.65\columnwidth]{development_model_without_papers}
% 	\caption{The stages of the FDD model and their relationship to other
%           Software Engineering concepts.}
% 	\label{fig:devmodel}
% \end{figure}

% We also have lists:

% \begin{enumerate}
%   \item Static Analysis~\circled{3} examines program artifacts or
%     their source code without executing them~\cite{wichmann1995industrial}, while
%  \item Dynamic Analysis~\circled{4} relies on information gathered from their
%    execution~\cite{cornelissen2009systematic}.
% \end{enumerate}

% Or boxes:

% \begin{framed}
% This thesis is concerned with the empirical assessment of the state of the art of how developers
% drive software development with the help of feedback loops.
% \end{framed}

% Or code:
% \begin{lstlisting}[caption={\textsc{TrinityCore}},label={lst:e1}]
%  x += other.x;
%  y += other.y;
%  z += other.y;
% \end{lstlisting}




% Long: \acrlong{fdd}

% Short: \acrshort{fdd}

% Full: \acrfull{fdd}
